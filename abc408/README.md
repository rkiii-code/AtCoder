# ABC408 2025/05/31 SAT

## A - Timeout

数列$`T`$に対して，長老が寝てしまうかを判定して**Yes**か**No**を返す．

初めの時間を$`T_0 = 0`$として，$`T_1`$~$`T_N`$すべてに対して，$`T_i-T_{i-1} < S+0.5 `$　($`1 \leq i \leq N`$)が成り立つなら**Yes**そうでないなら**No**.

## B -  Compression

入力をC++の**std::set**に入れて管理すればそのまま答えになる．

**std::vector**でも**std::unique**を使えばうまくできるらしい

```cpp
vector<int> a(n);
    for (int &i : a)
        cin >> i;
sort(a.begin(), a.end());
a.erase(unique(a.begin(), a.end()), a.end());
````

## C - Not All Covered

累積和を使う問題．[imos法](https://imoz.jp/algorithms/imos_method.html)
と呼ばれるアルゴリズムがあるらしい．

$`C_i`$は$i$番目の壁がいくつの砲台に守られているかを表す．以下のように$`C_i`$を求めると$`O(N+M)`$で求められる．

- $`C_1`$ ~ $`C_N+1`$ を $0$ で更新する.
- $l$ と $r$ の入力を受けて，$C_l+1$, $C_r-1$で更新する．
- $`C_1`$ ~ $`C_N`$ までの累積和 sum を計算しながら最小値 mi をだす．$`\text{mi} = \text{min}(\text{sum}, \text{mi})`$

## D - Flip to Gather

$i$番目までの$0$, $1$の個数をそれぞれ$`Z_i`$, $`O_i`$とする．
$1$ である区間の添え字最小と最大を  $l$, $r$ とすると，$l$ と $r$ の中にある$0$の個数分の操作が必要．これは $`Z_{r-1}-Z_{l-1}`$である．逆に範囲に含まれない $1$ の個数は $`O_N-(O_{r-1}-O_{l-1})`$なので，全体で $`Z_{r-1}-Z_{l-1}+O_N-(O_{r-1}-O_{l-1})`$です．
$Z_N$ は固定なので $`O_{l-1}-Z_{l-1}-O_{r-1}+Z_{r-1}`$の最大値がほしい．
配列を最初から見ながら$`O_{r-1}+Z_{r-1}`$の最大値と$`\text{min}(O_{l-1}-Z_{l-1}-\text{max}(O_{r-1}-Z_{r-1}))`$を計算していけば$`O(N)`$で解くことができる．
